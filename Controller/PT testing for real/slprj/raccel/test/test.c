#include "test.h"
#include "test_types.h"
#include <string.h>
#include "rtwtypes.h"
#include <stddef.h>
#include "rt_logging_mmi.h"
#include "test_capi.h"
#include "test_dt.h"
extern void * CreateDiagnosticAsVoidPtr_wrapper ( const char * id , int nargs
, ... ) ; RTWExtModeInfo * gblRTWExtModeInfo = NULL ; void
raccelForceExtModeShutdown ( boolean_T extModeStartPktReceived ) { if ( !
extModeStartPktReceived ) { boolean_T stopRequested = false ;
rtExtModeWaitForStartPkt ( gblRTWExtModeInfo , 1 , & stopRequested ) ; }
rtExtModeShutdown ( 1 ) ; }
#include "slsv_diagnostic_codegen_c_api.h"
#include "slsa_engine_exec.h"
#ifdef RSIM_WITH_SOLVER_MULTITASKING
boolean_T gbl_raccel_isMultitasking = 1 ;
#else
boolean_T gbl_raccel_isMultitasking = 0 ;
#endif
boolean_T gbl_raccel_tid01eq = 0 ; int_T gbl_raccel_NumST = 2 ; const char_T
* gbl_raccel_Version = "25.1 (R2025a) 21-Nov-2024" ; void
raccel_setup_MMIStateLog ( SimStruct * S ) {
#ifdef UseMMIDataLogging
rt_FillStateSigInfoFromMMI ( ssGetRTWLogInfo ( S ) , & ssGetErrorStatus ( S )
) ;
#else
UNUSED_PARAMETER ( S ) ;
#endif
} static DataMapInfo rt_dataMapInfo ; DataMapInfo * rt_dataMapInfoPtr = &
rt_dataMapInfo ; rtwCAPI_ModelMappingInfo * rt_modelMapInfoPtr = & ( rt_dataMapInfo . mmi ) ; int_T enableFcnCallFlag [ ] = { 1 , 1 } ; const char * raccelLoadInputsAndAperiodicHitTimes ( SimStruct * S , const char * inportFileName , int * matFileFormat ) { return rt_RAccelReadInportsMatFile ( S , inportFileName , matFileFormat ) ; }
#include "simstruc.h"
#include "fixedpoint.h"
#include "slsa_engine_exec.h"
#include "simtarget/slSimTgtSLExecSimBridge.h"
B rtB ; DW rtDW ; static SimStruct model_S ; SimStruct * const rtS = &
model_S ; static void d11v3yes0n ( jxpuqx0xdp * obj ) ; static void
d11v3yes0n ( jxpuqx0xdp * obj ) { obj -> isInitialized = 1 ; obj ->
I2CDriverObj . MW_I2C_HANDLE = MW_I2C_Open ( 0 , MW_I2C_MASTER ) ; obj ->
BusSpeed = 100000U ; MW_I2C_SetBusSpeed ( obj -> I2CDriverObj . MW_I2C_HANDLE
, obj -> BusSpeed ) ; obj -> isSetupComplete = true ; } void MdlStart ( void
) { { bool externalInputIsInDatasetFormat = false ; void * pISigstreamManager
= rt_GetISigstreamManager ( rtS ) ;
rtwISigstreamManagerGetInputIsInDatasetFormat ( pISigstreamManager , &
externalInputIsInDatasetFormat ) ; if ( externalInputIsInDatasetFormat ) { }
} rtDW . dterrpaahg . DefaultMaximumBusSpeedInHz = 400000.0 ; rtDW .
dterrpaahg . matlabCodegenIsDeleted = false ; rtDW . njtl3loymi = true ; rtDW
. dterrpaahg . isInitialized = 1 ; rtDW . dterrpaahg . I2CDriverObj .
MW_I2C_HANDLE = MW_I2C_Open ( 0 , MW_I2C_MASTER ) ; rtDW . dterrpaahg .
BusSpeed = 100000U ; MW_I2C_SetBusSpeed ( rtDW . dterrpaahg . I2CDriverObj .
MW_I2C_HANDLE , 100000U ) ; rtDW . dterrpaahg . isSetupComplete = true ; rtDW
. lgdvbio3nr . DefaultMaximumBusSpeedInHz = 400000.0 ; rtDW . lgdvbio3nr .
isInitialized = 0 ; rtDW . lgdvbio3nr . I2CDriverObj . MW_I2C_HANDLE = NULL ;
rtDW . lgdvbio3nr . matlabCodegenIsDeleted = false ; rtDW . cjauvfge1b = true
; d11v3yes0n ( & rtDW . lgdvbio3nr ) ; rtDW . mxycizfyds .
DefaultMaximumBusSpeedInHz = 400000.0 ; rtDW . mxycizfyds . isInitialized = 0
; rtDW . mxycizfyds . I2CDriverObj . MW_I2C_HANDLE = NULL ; rtDW . mxycizfyds
. matlabCodegenIsDeleted = false ; rtDW . kffxo0ncft = true ; d11v3yes0n ( &
rtDW . mxycizfyds ) ; rtDW . pe4vl5qeqg . DefaultMaximumBusSpeedInHz =
400000.0 ; rtDW . pe4vl5qeqg . isInitialized = 0 ; rtDW . pe4vl5qeqg .
I2CDriverObj . MW_I2C_HANDLE = NULL ; rtDW . pe4vl5qeqg .
matlabCodegenIsDeleted = false ; rtDW . bgzt3xzqch = true ; d11v3yes0n ( &
rtDW . pe4vl5qeqg ) ; } void MdlOutputs ( int_T tid ) { uint8_T
b_SwappedDataBytes [ 2 ] ; uint8_T output_raw ; b_SwappedDataBytes [ 0 ] = 1U
; b_SwappedDataBytes [ 1 ] = rtP . Constant_Value ; MW_I2C_MasterWrite ( rtDW
. dterrpaahg . I2CDriverObj . MW_I2C_HANDLE , 109U , & b_SwappedDataBytes [ 0
] , 2U , false , false ) ; output_raw = 4U ; rtB . exjjb34s5y =
MW_I2C_MasterWrite ( rtDW . lgdvbio3nr . I2CDriverObj . MW_I2C_HANDLE , 109U
, & output_raw , 1U , true , false ) ; if ( rtB . exjjb34s5y == 0 ) {
MW_I2C_MasterRead ( rtDW . lgdvbio3nr . I2CDriverObj . MW_I2C_HANDLE , 109U ,
& output_raw , 1U , false , true ) ; memcpy ( ( void * ) & rtB . of4v41xvws ,
( void * ) & output_raw , ( uint32_T ) ( ( size_t ) 1 * sizeof ( uint8_T ) )
) ; } else { rtB . of4v41xvws = 0U ; } output_raw = 5U ; rtB . gekw2nmb2u =
MW_I2C_MasterWrite ( rtDW . mxycizfyds . I2CDriverObj . MW_I2C_HANDLE , 109U
, & output_raw , 1U , true , false ) ; if ( rtB . gekw2nmb2u == 0 ) {
MW_I2C_MasterRead ( rtDW . mxycizfyds . I2CDriverObj . MW_I2C_HANDLE , 109U ,
& output_raw , 1U , false , true ) ; memcpy ( ( void * ) & rtB . a50ayrzv4u ,
( void * ) & output_raw , ( uint32_T ) ( ( size_t ) 1 * sizeof ( uint8_T ) )
) ; } else { rtB . a50ayrzv4u = 0U ; } output_raw = 6U ; rtB . pxo33x15ls =
MW_I2C_MasterWrite ( rtDW . pe4vl5qeqg . I2CDriverObj . MW_I2C_HANDLE , 109U
, & output_raw , 1U , true , false ) ; if ( rtB . pxo33x15ls == 0 ) {
MW_I2C_MasterRead ( rtDW . pe4vl5qeqg . I2CDriverObj . MW_I2C_HANDLE , 109U ,
& output_raw , 1U , false , true ) ; memcpy ( ( void * ) & rtB . pud5qanf3w ,
( void * ) & output_raw , ( uint32_T ) ( ( size_t ) 1 * sizeof ( uint8_T ) )
) ; } else { rtB . pud5qanf3w = 0U ; } UNUSED_PARAMETER ( tid ) ; } void
MdlOutputsTID1 ( int_T tid ) { UNUSED_PARAMETER ( tid ) ; } void MdlUpdate ( int_T tid ) { UNUSED_PARAMETER ( tid ) ; } void MdlUpdateTID1 ( int_T tid ) { UNUSED_PARAMETER ( tid ) ; } void MdlTerminate ( void ) { if ( ! rtDW . dterrpaahg . matlabCodegenIsDeleted ) { rtDW . dterrpaahg . matlabCodegenIsDeleted = true ; if ( ( rtDW . dterrpaahg . isInitialized == 1 ) && rtDW . dterrpaahg . isSetupComplete ) { MW_I2C_Close ( rtDW . dterrpaahg . I2CDriverObj . MW_I2C_HANDLE ) ; } } if ( ! rtDW . lgdvbio3nr . matlabCodegenIsDeleted ) { rtDW . lgdvbio3nr . matlabCodegenIsDeleted = true ; if ( ( rtDW . lgdvbio3nr . isInitialized == 1 ) && rtDW . lgdvbio3nr . isSetupComplete ) { MW_I2C_Close ( rtDW . lgdvbio3nr . I2CDriverObj . MW_I2C_HANDLE ) ; } } if ( ! rtDW . mxycizfyds . matlabCodegenIsDeleted ) { rtDW . mxycizfyds . matlabCodegenIsDeleted = true ; if ( ( rtDW . mxycizfyds . isInitialized == 1 ) && rtDW . mxycizfyds . isSetupComplete ) { MW_I2C_Close ( rtDW . mxycizfyds . I2CDriverObj . MW_I2C_HANDLE ) ; } } if ( ! rtDW . pe4vl5qeqg . matlabCodegenIsDeleted ) { rtDW . pe4vl5qeqg . matlabCodegenIsDeleted = true ; if ( ( rtDW . pe4vl5qeqg . isInitialized == 1 ) && rtDW . pe4vl5qeqg . isSetupComplete ) { MW_I2C_Close ( rtDW . pe4vl5qeqg . I2CDriverObj . MW_I2C_HANDLE ) ; } } } static void mr_test_cacheDataAsMxArray ( mxArray * destArray , mwIndex i , int j , const void * srcData , size_t numBytes ) ; static void mr_test_cacheDataAsMxArray ( mxArray * destArray , mwIndex i , int j , const void * srcData , size_t numBytes ) { mxArray * newArray = mxCreateUninitNumericMatrix ( ( size_t ) 1 , numBytes , mxUINT8_CLASS , mxREAL ) ; memcpy ( ( uint8_T * ) mxGetData ( newArray ) , ( const uint8_T * ) srcData , numBytes ) ; mxSetFieldByNumber ( destArray , i , j , newArray ) ; } static void mr_test_restoreDataFromMxArray ( void * destData , const mxArray * srcArray , mwIndex i , int j , size_t numBytes ) ; static void mr_test_restoreDataFromMxArray ( void * destData , const mxArray * srcArray , mwIndex i , int j , size_t numBytes ) { memcpy ( ( uint8_T * ) destData , ( const uint8_T * ) mxGetData ( mxGetFieldByNumber ( srcArray , i , j ) ) , numBytes ) ; } static void mr_test_cacheBitFieldToMxArray ( mxArray * destArray , mwIndex i , int j , uint_T bitVal ) ; static void mr_test_cacheBitFieldToMxArray ( mxArray * destArray , mwIndex i , int j , uint_T bitVal ) { mxSetFieldByNumber ( destArray , i , j , mxCreateDoubleScalar ( ( real_T ) bitVal ) ) ; } static uint_T mr_test_extractBitFieldFromMxArray ( const mxArray * srcArray , mwIndex i , int j , uint_T numBits ) ; static uint_T mr_test_extractBitFieldFromMxArray ( const mxArray * srcArray , mwIndex i , int j , uint_T numBits ) { const uint_T varVal = ( uint_T ) mxGetScalar ( mxGetFieldByNumber ( srcArray , i , j ) ) ; return varVal & ( ( 1u << numBits ) - 1u ) ; } static void mr_test_cacheDataToMxArrayWithOffset ( mxArray * destArray , mwIndex i , int j , mwIndex offset , const void * srcData , size_t numBytes ) ; static void mr_test_cacheDataToMxArrayWithOffset ( mxArray * destArray , mwIndex i , int j , mwIndex offset , const void * srcData , size_t numBytes ) { uint8_T * varData = ( uint8_T * ) mxGetData ( mxGetFieldByNumber ( destArray , i , j ) ) ; memcpy ( ( uint8_T * ) & varData [ offset * numBytes ] , ( const uint8_T * ) srcData , numBytes ) ; } static void mr_test_restoreDataFromMxArrayWithOffset ( void * destData , const mxArray * srcArray , mwIndex i , int j , mwIndex offset , size_t numBytes ) ; static void mr_test_restoreDataFromMxArrayWithOffset ( void * destData , const mxArray * srcArray , mwIndex i , int j , mwIndex offset , size_t numBytes ) { const uint8_T * varData = ( const uint8_T * ) mxGetData ( mxGetFieldByNumber ( srcArray , i , j ) ) ; memcpy ( ( uint8_T * ) destData , ( const uint8_T * ) & varData [ offset * numBytes ] , numBytes ) ; } static void mr_test_cacheBitFieldToCellArrayWithOffset ( mxArray * destArray , mwIndex i , int j , mwIndex offset , uint_T fieldVal ) ; static void mr_test_cacheBitFieldToCellArrayWithOffset ( mxArray * destArray , mwIndex i , int j , mwIndex offset , uint_T fieldVal ) { mxSetCell ( mxGetFieldByNumber ( destArray , i , j ) , offset , mxCreateDoubleScalar ( ( real_T ) fieldVal ) ) ; } static uint_T mr_test_extractBitFieldFromCellArrayWithOffset ( const mxArray * srcArray , mwIndex i , int j , mwIndex offset , uint_T numBits ) ; static uint_T mr_test_extractBitFieldFromCellArrayWithOffset ( const mxArray * srcArray , mwIndex i , int j , mwIndex offset , uint_T numBits ) { const uint_T fieldVal = ( uint_T ) mxGetScalar ( mxGetCell ( mxGetFieldByNumber ( srcArray , i , j ) , offset ) ) ; return fieldVal & ( ( 1u << numBits ) - 1u ) ; } mxArray * mr_test_GetDWork ( ) { static const char_T * ssDWFieldNames [ 3 ] = { "rtB" , "rtDW" , "NULL_PrevZCX" , } ; mxArray * ssDW = mxCreateStructMatrix ( 1 , 1 , 3 , ssDWFieldNames ) ; mr_test_cacheDataAsMxArray ( ssDW , 0 , 0 , ( const void * ) & ( rtB ) , sizeof ( rtB ) ) ; { static const char_T * rtdwDataFieldNames [ 8 ] = { "rtDW.pe4vl5qeqg" , "rtDW.mxycizfyds" , "rtDW.lgdvbio3nr" , "rtDW.dterrpaahg" , "rtDW.njtl3loymi" , "rtDW.bgzt3xzqch" , "rtDW.kffxo0ncft" , "rtDW.cjauvfge1b" , } ; mxArray * rtdwData = mxCreateStructMatrix ( 1 , 1 , 8 , rtdwDataFieldNames ) ; mr_test_cacheDataAsMxArray ( rtdwData , 0 , 0 , ( const void * ) & ( rtDW . pe4vl5qeqg ) , sizeof ( rtDW . pe4vl5qeqg ) ) ; mr_test_cacheDataAsMxArray ( rtdwData , 0 , 1 , ( const void * ) & ( rtDW . mxycizfyds ) , sizeof ( rtDW . mxycizfyds ) ) ; mr_test_cacheDataAsMxArray ( rtdwData , 0 , 2 , ( const void * ) & ( rtDW . lgdvbio3nr ) , sizeof ( rtDW . lgdvbio3nr ) ) ; mr_test_cacheDataAsMxArray ( rtdwData , 0 , 3 , ( const void * ) & ( rtDW . dterrpaahg ) , sizeof ( rtDW . dterrpaahg ) ) ; mr_test_cacheDataAsMxArray ( rtdwData , 0 , 4 , ( const void * ) & ( rtDW . njtl3loymi ) , sizeof ( rtDW . njtl3loymi ) ) ; mr_test_cacheDataAsMxArray ( rtdwData , 0 , 5 , ( const void * ) & ( rtDW . bgzt3xzqch ) , sizeof ( rtDW . bgzt3xzqch ) ) ; mr_test_cacheDataAsMxArray ( rtdwData , 0 , 6 , ( const void * ) & ( rtDW . kffxo0ncft ) , sizeof ( rtDW . kffxo0ncft ) ) ; mr_test_cacheDataAsMxArray ( rtdwData , 0 , 7 , ( const void * ) & ( rtDW . cjauvfge1b ) , sizeof ( rtDW . cjauvfge1b ) ) ; mxSetFieldByNumber ( ssDW , 0 , 1 , rtdwData ) ; } return ssDW ; } void mr_test_SetDWork ( const mxArray * ssDW ) { ( void ) ssDW ; mr_test_restoreDataFromMxArray ( ( void * ) & ( rtB ) , ssDW , 0 , 0 , sizeof ( rtB ) ) ; { const mxArray * rtdwData = mxGetFieldByNumber ( ssDW , 0 , 1 ) ; mr_test_restoreDataFromMxArray ( ( void * ) & ( rtDW . pe4vl5qeqg ) , rtdwData , 0 , 0 , sizeof ( rtDW . pe4vl5qeqg ) ) ; mr_test_restoreDataFromMxArray ( ( void * ) & ( rtDW . mxycizfyds ) , rtdwData , 0 , 1 , sizeof ( rtDW . mxycizfyds ) ) ; mr_test_restoreDataFromMxArray ( ( void * ) & ( rtDW . lgdvbio3nr ) , rtdwData , 0 , 2 , sizeof ( rtDW . lgdvbio3nr ) ) ; mr_test_restoreDataFromMxArray ( ( void * ) & ( rtDW . dterrpaahg ) , rtdwData , 0 , 3 , sizeof ( rtDW . dterrpaahg ) ) ; mr_test_restoreDataFromMxArray ( ( void * ) & ( rtDW . njtl3loymi ) , rtdwData , 0 , 4 , sizeof ( rtDW . njtl3loymi ) ) ; mr_test_restoreDataFromMxArray ( ( void * ) & ( rtDW . bgzt3xzqch ) , rtdwData , 0 , 5 , sizeof ( rtDW . bgzt3xzqch ) ) ; mr_test_restoreDataFromMxArray ( ( void * ) & ( rtDW . kffxo0ncft ) , rtdwData , 0 , 6 , sizeof ( rtDW . kffxo0ncft ) ) ; mr_test_restoreDataFromMxArray ( ( void * ) & ( rtDW . cjauvfge1b ) , rtdwData , 0 , 7 , sizeof ( rtDW . cjauvfge1b ) ) ; } } mxArray * mr_test_GetSimStateDisallowedBlocks ( ) { mxArray * data = mxCreateCellMatrix ( 4 , 3 ) ; mwIndex subs [ 2 ] , offset ; { static const char_T * blockType [ 4 ] = { "MATLABSystem" , "MATLABSystem" , "MATLABSystem" , "MATLABSystem" , } ; static const char_T * blockPath [ 4 ] = { "test/I2C Read" , "test/I2C Read1" , "test/I2C Read2" , "test/I2C Write" , } ; static const int reason [ 4 ] = { 6 , 6 , 6 , 6 , } ; for ( subs [ 0 ] = 0 ; subs [ 0 ] < 4 ; ++ ( subs [ 0 ] ) ) { subs [ 1 ] = 0 ; offset = mxCalcSingleSubscript ( data , 2 , subs ) ; mxSetCell ( data , offset , mxCreateString ( blockType [ subs [ 0 ] ] ) ) ; subs [ 1 ] = 1 ; offset = mxCalcSingleSubscript ( data , 2 , subs ) ; mxSetCell ( data , offset , mxCreateString ( blockPath [ subs [ 0 ] ] ) ) ; subs [ 1 ] = 2 ; offset = mxCalcSingleSubscript ( data , 2 , subs ) ; mxSetCell ( data , offset , mxCreateDoubleScalar ( ( real_T ) reason [ subs [ 0 ] ] ) ) ; } } return data ; } void MdlInitializeSizes ( void ) { ssSetNumContStates ( rtS , 0 ) ; ssSetNumY ( rtS , 0 ) ; ssSetNumU ( rtS , 0 ) ; ssSetDirectFeedThrough ( rtS , 0 ) ; ssSetNumSampleTimes ( rtS , 1 ) ; ssSetNumBlocks ( rtS , 15 ) ; ssSetNumBlockIO ( rtS , 6 ) ; ssSetNumBlockParams ( rtS , 1 ) ; } void MdlInitializeSampleTimes ( void ) { ssSetSampleTime ( rtS , 0 , 0.1 ) ; ssSetOffsetTime ( rtS , 0 , 0.0 ) ; } void raccel_set_checksum ( ) { ssSetChecksumVal ( rtS , 0 , 268456500U ) ; ssSetChecksumVal ( rtS , 1 , 2230381867U ) ; ssSetChecksumVal ( rtS , 2 , 1221417461U ) ; ssSetChecksumVal ( rtS , 3 , 2293181659U ) ; }
#if defined(_MSC_VER)
#pragma optimize( "", off )
#endif
SimStruct * raccel_register_model ( ssExecutionInfo * executionInfo ) {
static struct _ssMdlInfo mdlInfo ; static struct _ssBlkInfo2 blkInfo2 ;
static struct _ssBlkInfoSLSize blkInfoSLSize ; rt_modelMapInfoPtr = & ( rt_dataMapInfo . mmi ) ; executionInfo -> gblObjects_ . numToFiles = 0 ; executionInfo -> gblObjects_ . numFrFiles = 0 ; executionInfo -> gblObjects_ . numFrWksBlocks = 0 ; executionInfo -> gblObjects_ . numModelInputs = 0 ; executionInfo -> gblObjects_ . numRootInportBlks = 0 ; executionInfo -> gblObjects_ . inportDataTypeIdx = NULL ; executionInfo -> gblObjects_ . inportDims = NULL ; executionInfo -> gblObjects_ . inportComplex = NULL ; executionInfo -> gblObjects_ . inportInterpoFlag = NULL ; executionInfo -> gblObjects_ . inportContinuous = NULL ; ( void ) memset ( ( char_T * ) rtS , 0 , sizeof ( SimStruct ) ) ; ( void ) memset ( ( char_T * ) & mdlInfo , 0 , sizeof ( struct _ssMdlInfo ) ) ; ( void ) memset ( ( char_T * ) & blkInfo2 , 0 , sizeof ( struct _ssBlkInfo2 ) ) ; ( void ) memset ( ( char_T * ) & blkInfoSLSize , 0 , sizeof ( struct _ssBlkInfoSLSize ) ) ; ssSetBlkInfo2Ptr ( rtS , & blkInfo2 ) ; ssSetBlkInfoSLSizePtr ( rtS , & blkInfoSLSize ) ; ssSetMdlInfoPtr ( rtS , & mdlInfo ) ; ssSetExecutionInfo ( rtS , executionInfo ) ; slsaAllocOPModelData ( rtS ) ; { static time_T mdlPeriod [ NSAMPLE_TIMES ] ; static time_T mdlOffset [ NSAMPLE_TIMES ] ; static time_T mdlTaskTimes [ NSAMPLE_TIMES ] ; static int_T mdlTsMap [ NSAMPLE_TIMES ] ; static int_T mdlSampleHits [ NSAMPLE_TIMES ] ; static boolean_T mdlTNextWasAdjustedPtr [ NSAMPLE_TIMES ] ; static int_T mdlPerTaskSampleHits [ NSAMPLE_TIMES * NSAMPLE_TIMES ] ; static time_T mdlTimeOfNextSampleHit [ NSAMPLE_TIMES ] ; { int_T i ; for ( i = 0 ; i < NSAMPLE_TIMES ; i ++ ) { mdlPeriod [ i ] = 0.0 ; mdlOffset [ i ] = 0.0 ; mdlTaskTimes [ i ] = 0.0 ; mdlTsMap [ i ] = i ; mdlSampleHits [ i ] = 1 ; } } ssSetSampleTimePtr ( rtS , & mdlPeriod [ 0 ] ) ; ssSetOffsetTimePtr ( rtS , & mdlOffset [ 0 ] ) ; ssSetSampleTimeTaskIDPtr ( rtS , & mdlTsMap [ 0 ] ) ; ssSetTPtr ( rtS , & mdlTaskTimes [ 0 ] ) ; ssSetSampleHitPtr ( rtS , & mdlSampleHits [ 0 ] ) ; ssSetTNextWasAdjustedPtr ( rtS , & mdlTNextWasAdjustedPtr [ 0 ] ) ; ssSetPerTaskSampleHitsPtr ( rtS , & mdlPerTaskSampleHits [ 0 ] ) ; ssSetTimeOfNextSampleHitPtr ( rtS , & mdlTimeOfNextSampleHit [ 0 ] ) ; } ssSetSolverMode ( rtS , SOLVER_MODE_SINGLETASKING ) ; { ssSetBlockIO ( rtS , ( ( void * ) & rtB ) ) ; ( void ) memset ( ( ( void * ) & rtB ) , 0 , sizeof ( B ) ) ; } { void * dwork = ( void * ) & rtDW ; ssSetRootDWork ( rtS , dwork ) ; ( void ) memset ( dwork , 0 , sizeof ( DW ) ) ; } { static DataTypeTransInfo dtInfo ; ( void ) memset ( ( char_T * ) & dtInfo , 0 , sizeof ( dtInfo ) ) ; ssSetModelMappingInfo ( rtS , & dtInfo ) ; dtInfo . numDataTypes = 25 ; dtInfo . dataTypeSizes = & rtDataTypeSizes [ 0 ] ; dtInfo . dataTypeNames = & rtDataTypeNames [ 0 ] ; dtInfo . BTransTable = & rtBTransTable ; dtInfo . PTransTable = & rtPTransTable ; dtInfo . dataTypeInfoTable = rtDataTypeInfoTable ; } test_InitializeDataMapInfo ( ) ; ssSetIsRapidAcceleratorActive ( rtS , true ) ; ssSetRootSS ( rtS , rtS ) ; ssSetVersion ( rtS , SIMSTRUCT_VERSION_LEVEL2 ) ; ssSetModelName ( rtS , "test" ) ; ssSetPath ( rtS , "test" ) ; ssSetTStart ( rtS , 0.0 ) ; ssSetTFinal ( rtS , INFINITY ) ; ssSetStepSize ( rtS , 0.1 ) ; ssSetFixedStepSize ( rtS , 0.1 ) ; { static RTWLogInfo rt_DataLoggingInfo ; rt_DataLoggingInfo . loggingInterval = ( NULL ) ; ssSetRTWLogInfo ( rtS , & rt_DataLoggingInfo ) ; } { rtliSetLogT ( ssGetRTWLogInfo ( rtS ) , "tout" ) ; rtliSetLogX ( ssGetRTWLogInfo ( rtS ) , "" ) ; rtliSetLogXFinal ( ssGetRTWLogInfo ( rtS ) , "" ) ; rtliSetLogVarNameModifier ( ssGetRTWLogInfo ( rtS ) , "none" ) ; rtliSetLogFormat ( ssGetRTWLogInfo ( rtS ) , 4 ) ; rtliSetLogMaxRows ( ssGetRTWLogInfo ( rtS ) , 0 ) ; rtliSetLogDecimation ( ssGetRTWLogInfo ( rtS ) , 1 ) ; rtliSetLogY ( ssGetRTWLogInfo ( rtS ) , "" ) ; rtliSetLogYSignalInfo ( ssGetRTWLogInfo ( rtS ) , ( NULL ) ) ; rtliSetLogYSignalPtrs ( ssGetRTWLogInfo ( rtS ) , ( NULL ) ) ; } { static ssSolverInfo slvrInfo ; ssSetNumNonContDerivSigInfos ( rtS , 0 ) ; ssSetNonContDerivSigInfos ( rtS , ( NULL ) ) ; ssSetSolverInfo ( rtS , & slvrInfo ) ; ssSetSolverName ( rtS , "FixedStepDiscrete" ) ; ssSetVariableStepSolver ( rtS , 0 ) ; ssSetSolverConsistencyChecking ( rtS , 0 ) ; ssSetSolverAdaptiveZcDetection ( rtS , 0 ) ; ssSetSolverRobustResetMethod ( rtS , 0 ) ; ssSetSolverStateProjection ( rtS , 0 ) ; ssSetSolverMassMatrixType ( rtS , ( ssMatrixType ) 0 ) ; ssSetSolverMassMatrixNzMax ( rtS , 0 ) ; ssSetModelOutputs ( rtS , MdlOutputs ) ; ssSetModelUpdate ( rtS , MdlUpdate ) ; ssSetTNextTid ( rtS , INT_MIN ) ; ssSetTNext ( rtS , rtMinusInf ) ; ssSetSolverNeedsReset ( rtS ) ; ssSetNumNonsampledZCs ( rtS , 0 ) ; } ssSetChecksumVal ( rtS , 0 , 268456500U ) ; ssSetChecksumVal ( rtS , 1 , 2230381867U ) ; ssSetChecksumVal ( rtS , 2 , 1221417461U ) ; ssSetChecksumVal ( rtS , 3 , 2293181659U ) ; { static const sysRanDType rtAlwaysEnabled = SUBSYS_RAN_BC_ENABLE ; static RTWExtModeInfo rt_ExtModeInfo ; static const sysRanDType * systemRan [ 5 ] ; gblRTWExtModeInfo = & rt_ExtModeInfo ; ssSetRTWExtModeInfo ( rtS , & rt_ExtModeInfo ) ; rteiSetSubSystemActiveVectorAddresses ( & rt_ExtModeInfo , systemRan ) ; systemRan [ 0 ] = & rtAlwaysEnabled ; systemRan [ 1 ] = & rtAlwaysEnabled ; systemRan [ 2 ] = & rtAlwaysEnabled ; systemRan [ 3 ] = & rtAlwaysEnabled ; systemRan [ 4 ] = & rtAlwaysEnabled ; rteiSetModelMappingInfoPtr ( ssGetRTWExtModeInfo ( rtS ) , & ssGetModelMappingInfo ( rtS ) ) ; rteiSetChecksumsPtr ( ssGetRTWExtModeInfo ( rtS ) , ssGetChecksums ( rtS ) ) ; rteiSetTPtr ( ssGetRTWExtModeInfo ( rtS ) , ssGetTPtr ( rtS ) ) ; } slsaDisallowedBlocksForSimTargetOP ( rtS , mr_test_GetSimStateDisallowedBlocks ) ; slsaGetWorkFcnForSimTargetOP ( rtS , mr_test_GetDWork ) ; slsaSetWorkFcnForSimTargetOP ( rtS , mr_test_SetDWork ) ; rt_RapidReadMatFileAndUpdateParams ( rtS ) ; if ( ssGetErrorStatus ( rtS ) ) { return rtS ; } executionInfo -> simulationOptions_ . stateSaveName_ = rtliGetLogX ( ssGetRTWLogInfo ( rtS ) ) ; executionInfo -> simulationOptions_ . finalStateName_ = rtliGetLogXFinal ( ssGetRTWLogInfo ( rtS ) ) ; executionInfo -> simulationOptions_ . outputSaveName_ = rtliGetLogY ( ssGetRTWLogInfo ( rtS ) ) ; executionInfo -> simulationOptions_ . inputTimeTolerance_ = 0.0 ; return rtS ; }
#if defined(_MSC_VER)
#pragma optimize( "", on )
#endif
void MdlOutputsParameterSampleTime ( int_T tid ) { MdlOutputsTID1 ( tid ) ; }
